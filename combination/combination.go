package combination

func Combination(params [][]interface{}) (results [][]interface{}) {
	var pCount = 1
	for _, p := range params {
		pCount = pCount * len(p)
	}
	results = make([][]interface{}, 0, 0)

	var psLen = len(params)
	for i:=0; i<pCount; i++ {
		var s = make([]interface{}, 0, 0)
		var temp = i
		for m:=0; m<psLen; m++ {
			var pLen = len(params[m])
			if (temp / pLen) >= 0 {
				s = append(s, params[m][temp % pLen])
				temp /= pLen
			}
		}
		results = append(results, s)
	}
	return results
}

/*

假设存在：
数组 A = [1, 2, 3, 4]
数组 B = [A, B, C, D]
数组 C = [a, b]

求：
数组A、B、C的全排列组合？

解：
分别从每一个数组中取出一个元素，然后组成一个新的数组，根据排列组合可以知道，总共会产生 4*4*2=32 个新的数组组合。

可能产生新的数组组合如下：

（最左边的数值为索引，中间为新数组的值，右边为新数组元素在原数组中的下标。）

00 - [1 A a] - [0][0][0]
01 - [2 A a] - [1][0][0]
02 - [3 A a] - [2][0][0]
03 - [4 A a] - [3][0][0]

04 - [1 B a] - [0][1][0]
05 - [2 B a] - [1][1][0]
06 - [3 B a] - [2][1][0]
07 - [4 B a] - [3][1][0]

08 - [1 C a] - [0][2][0]
09 - [2 C a] - [1][2][0]
10 - [3 C a] - [2][2][0]
11 - [4 C a] - [3][2][0]

12 - [1 D a] - [0][3][0]
13 - [2 D a] - [1][3][0]
14 - [3 D a] - [2][3][0]
15 - [4 D a] - [3][3][0]

16 - [1 A b] - [0][0][1]
17 - [2 A b] - [1][0][1]
18 - [3 A b] - [2][0][1]
19 - [4 A b] - [3][0][1]

20 - [1 B b] - [0][1][1]
21 - [2 B b] - [1][1][1]
22 - [3 B b] - [2][1][1]
23 - [4 B b] - [3][1][1]

24 - [1 C b] - [0][2][1]
25 - [2 C b] - [1][2][1]
26 - [3 C b] - [2][2][1]
27 - [4 C b] - [3][2][1]

28 - [1 D b] - [0][3][1]
29 - [2 D b] - [1][3][1]
30 - [3 D b] - [2][3][1]
31 - [4 D b] - [3][3][1]

新数组第一个元素：取自第一个数组，元素下标为 (索引值 % 第一个数组的长度)
新数组第二个元素：取自第二个数组，元素下标为（索引值 / 第一个数组的长度 % 第二个数组的长度）
新数组第三个元素：取自第三个数组，元素下标为（索引值 / 第一个数组的长度 / 第二个数组的长度 % 第三个数组的长度）
如果还有更多的数组，以此类推。

 */
