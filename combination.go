package nlist

// Combination 组合
// 假设存在：
// 数组 A = [1, 2, 3, 4]
// 数组 B = [A, B, C, D]
// 数组 C = [a, b]
//
// 求：
// 数组A、B、C的全排列组合？
//
// 解：
// 分别从每一个数组中取出一个元素，然后组成一个新的数组，总共会产生 4*4*2=32 个新的数组组合。
//
// 可能产生新的数组组合如下：
//
// （最左边的数值为索引，中间为新数组的值，右边为新数组元素在原数组中的下标。）
//
// 00 - [1 A a] - [0][0][0]
// 01 - [2 A a] - [1][0][0]
// 02 - [3 A a] - [2][0][0]
// 03 - [4 A a] - [3][0][0]
//
// 04 - [1 B a] - [0][1][0]
// 05 - [2 B a] - [1][1][0]
// 06 - [3 B a] - [2][1][0]
// 07 - [4 B a] - [3][1][0]
//
// 08 - [1 C a] - [0][2][0]
// 09 - [2 C a] - [1][2][0]
// 10 - [3 C a] - [2][2][0]
// 11 - [4 C a] - [3][2][0]
//
// 12 - [1 D a] - [0][3][0]
// 13 - [2 D a] - [1][3][0]
// 14 - [3 D a] - [2][3][0]
// 15 - [4 D a] - [3][3][0]
//
// 16 - [1 A b] - [0][0][1]
// 17 - [2 A b] - [1][0][1]
// 18 - [3 A b] - [2][0][1]
// 19 - [4 A b] - [3][0][1]
//
// 20 - [1 B b] - [0][1][1]
// 21 - [2 B b] - [1][1][1]
// 22 - [3 B b] - [2][1][1]
// 23 - [4 B b] - [3][1][1]
//
// 24 - [1 C b] - [0][2][1]
// 25 - [2 C b] - [1][2][1]
// 26 - [3 C b] - [2][2][1]
// 27 - [4 C b] - [3][2][1]
//
// 28 - [1 D b] - [0][3][1]
// 29 - [2 D b] - [1][3][1]
// 30 - [3 D b] - [2][3][1]
// 31 - [4 D b] - [3][3][1]
//
// 新数组第一个元素：取自第一个数组，元素下标为 (索引值 % 第一个数组的长度)
// 新数组第二个元素：取自第二个数组，元素下标为（索引值 / 第一个数组的长度 % 第二个数组的长度）
// 新数组第三个元素：取自第三个数组，元素下标为（索引值 / 第一个数组的长度 / 第二个数组的长度 % 第三个数组的长度）
// 如果还有更多的数组，以此类推。
func Combination[T any](params [][]T) [][]T {
	// 计算出组合数量
	var total = 1
	for _, p := range params {
		total = total * len(p)
	}

	var nList = make([][]T, 0, total)

	var elementsLen = len(params)
	for index := 0; index < total; index++ {
		var elements = make([]T, 0, elementsLen)
		var temp = index
		for m := 0; m < elementsLen; m++ {
			var pLen = len(params[m])
			elements = append(elements, params[m][temp%pLen])
			temp /= pLen
		}
		nList = append(nList, elements)
	}
	return nList
}
